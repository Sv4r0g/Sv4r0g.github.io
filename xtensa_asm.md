## Ассемблер Xtensa

Архитектура набора команд **Xtensa** (англ. Instruction Set Architecture) - это новая пост-RISC (Reduced instruction Set Computer) ISA, разработанная преимущественно для встраиваемых систем.
Этот короткий мануал представляет собой сборник часто встречающихся инструкций, а также описывает некоторые особенности ассемблера, такие как регистры, стек, ветвления, вызовы функций, переходы и т.д. Вся нижеизложенная информация взята из официальной [спецификации](https://0x04.net/~mwk/doc/xtensa.pdf) и автор настоятельно рекомендует использовать ее в качестве справочного руководства. 

Поводом для написания мануала послужило изучение популярных в среде интернета вещей платформ ESP8266, ESP32. Страница будет пополняться по мере поступления интересных деталей.

### Ряд существенных отличий от RISC

В Xtensa используются инструкции шириной 16 и 24 бита соответственно, когда как для RISC используются инструкции шириной 32 бита, также отсутствует [branch delay slot](https://en.wikipedia.org/wiki/Delay_slot).

### Регистры

В качестве базовых регистров стоит выделить AR и PC, где AR - адресный регистр (address register) общего назначения, А PC - счетчик команд (program counter). Максимальное количество AR регистров может достигать 256, но зачастую используется 16, где:

* a0 - адрес возврата
* a1/sp - указатель стека
* a2-a7 - аргументы функций
* a8 - "static chain"
* a12-a15 - регистры постоянного хранения[1]
* a15 - фрейм стека (опционально)

### Инструкции

#### Инструкции загрузки

```L8UI, L16SI, L16UI, L32I, L32R```

**Пример:**

```asm
0x4021b95b      l32r a2, 0x402103c8
0x4021b95e      call0 printf ; sym.printf ; int printf(const char *format)
```

#### Инструкции хранения

```S8I, S16I, S32I```

**Пример:**

```asm
0x4021b923      s32i a0, a1, 28
0x40218501      s8i a0, a2, 160
```

#### Безусловные переходы, вызовы

```CALL0, CALLX0, RET, J, JX```

**Пример:**

```asm
0x4021b9e9      call0 _svfprintf_r ; sym._svfprintf_r
0x40211329      j 0x40211333
```

#### Условные переходы
Инструкций для условных переходов в документации перечислено значительно больше, чем встречается на практике, но тем не менее я перечислю их здесь.

```BALL, BNALL, BANY, BNONEб BBC, BBCI, BBS, BBSI, BEQ, BEQI, BEQZб BNE, BNEI, BNEZ, BGE, BGEI, BGEU, BGEUI, BGEZ, BLT, BLTI, BLTU, BLTUI, BLTZ```

**Пример:**

```asm
0x4021b9ec      blt a2, a12, 0x4021b9f8 ; asprintf.c:78
0x4021134e      bnez a2, 0x40211342
```

#### Логические операции

```AND, OR, XOR```

**Пример:**

```asm
0x4021e7df      xor a2, a0, a0
0x40212891      and a13, a12, a13
0x4023c9cf      or a1, a1, a1
```

#### Арифметические операции

```ADDI, ADDMI, ADD, ADDX2, ADDX4, ADDX8, SUB, SUBX2, SUBX4, SUBX8, NEG, ABS```

**Пример:**

```asm
0x402116a0      addi a1, a1, 16
0x40223808      addmi a0, a2, 0x6100
0x402141a9      add a12, a13, a12
0x4022491d      addx2 a2, a2, a2 ; vfs.c:266         const int index = s_fd_table[fd].vfs_index; // single read -> no locking is required
0x402494a0      sub a10, a0, a6
0x4023f29a      neg a12, a12
...
```

#### Сдвиги

```EXTUI, SRLI, SRAI, SLLI SRC, SLL, SRL, SRA, SSL, SSR, SSAI, SSA8B, SSA8L```

Что касается сдвигов, то [cutter](https://cutter.re/)  не нашел в бинарнике ни одной подобной инструкции. Судя по документации, они могут использоваться для повышения производительности, возможно, при различных оптимизациях колмпилятора, но это нужно проверить. Также сдвиги часто можно встретить в малвари, шифровании на основе генераторов случайных чисел и т.д.

1. Я использовал вольный перевод для calee-saved registers, чтобы отобразить назначение регистров без потери смысла
